<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>tst</title>
    <script src="/5/test3D/lib/phaser.min.js_ver=3.52.0"></script>
    <script src="/5/test3D/lib/enable3d/enable3d.phaserExtension.0.25.4.min.js"></script>
  </head>

  <body>
    <script>
      const { enable3d, Scene3D, Canvas, THREE } = ENABLE3D;

      class MainScene extends Scene3D {
        constructor() {
          super({ key: "MainScene" });
        }

        init() {
          this.accessThirdDimension();
        }

        create() {
          this.third.warpSpeed("light", "fog", "orbitControls");
          this.third.physics.debug.enable();

          const textureLoader = new THREE.TextureLoader();

          const uniforms = {
            topColor: { value: new THREE.Color(0x0077ff) }, // Bleu clair pour le haut du ciel
            bottomColor: { value: new THREE.Color(0xffffff) }, // Blanc pour l'horizon
            offset: { value: 33 }, // Pour ajuster la position du dégradé
            exponent: { value: 0.6 }, // Pour contrôler la courbure du dégradé
          };

          const skyMat = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: `
            varying vec3 vWorldPosition;
            void main() {
              vec4 worldPosition = modelMatrix * vec4(position, 1.0);
              vWorldPosition = worldPosition.xyz;
              gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
          `,
            fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;

            varying vec3 vWorldPosition;

            void main() {
              float h = normalize(vWorldPosition + offset).y;
              gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
            }
          `,
            side: THREE.BackSide, // Inverser la sphère pour voir de l'intérieur
          });

          const skyGeometry = new THREE.SphereGeometry(4000, 32, 32);
          const skySphere = new THREE.Mesh(skyGeometry, skyMat);
          this.third.scene.add(skySphere);

          // Variables pour gérer le changement de couleur et l'opacité
          let isDay = true;
          const fadeDuration = 2000; // Durée du fondu en millisecondes
          let startTime = 0;

          // Tableau pour stocker les étoiles
          const stars = [];
          const starGeometry = new THREE.SphereGeometry(20, 8, 8); // Petite sphère pour représenter une étoile
          const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // Couleur blanche pour les étoiles

          const starRadius = 4000; // Rayon de la sphère (correspond à la sphère de nuit)
          for (let i = 0; i < 2000; i++) {
            // Créer 200 étoiles
            const star = new THREE.Mesh(starGeometry, starMaterial);

            // Calculer une position aléatoire sur la sphère
            const phi = Math.random() * Math.PI; // Angle azimutal
            const theta = Math.random() * 2 * Math.PI; // Angle polaire

            // Convertir les coordonnées sphériques en coordonnées cartésiennes
            const x = starRadius * Math.sin(phi) * Math.cos(theta);
            const y = starRadius * Math.cos(phi);
            const z = starRadius * Math.sin(phi) * Math.sin(theta);

            star.position.set(x, y, z); // Positionner l'étoile
            star.visible = false; // Cacher les étoiles par défaut
            stars.push(star); // Ajouter l'étoile au tableaus
            this.third.scene.add(star); // Ajouter chaque étoile à la scène
          }

          // Fonction pour changer la couleur de la sphère avec fondu
          const changeSkyColor = () => {
            startTime = performance.now(); // Obtenir l'heure de départ
            isDay = !isDay; // Changer l'état du jour à nuit ou vice versa

            // Gérer la visibilité des étoiles
            stars.forEach((star) => {
              star.visible = isDay; // Afficher les étoiles seulement la nuit
            });
          };

          const animateColorTransition = (timestamp) => {
            const elapsedTime = timestamp - startTime;

            // Calculer la progression du fondu
            const progress = Math.min(elapsedTime / fadeDuration, 1);

            // Interpoler les couleurs
            if (isDay) {
              uniforms.topColor.value.lerp(new THREE.Color(0x000033), progress); // Fondu vers le bleu foncé
              uniforms.bottomColor.value.lerp(
                new THREE.Color(0x0022bb),
                progress
              ); // Fondu vers le bleu foncé
            } else {
              uniforms.topColor.value.lerp(new THREE.Color(0x0077ff), progress); // Fondu vers le bleu clair
              uniforms.bottomColor.value.lerp(
                new THREE.Color(0xffffff),
                progress
              ); // Fondu vers le blanc
            }

            // Indiquer que les uniformes doivent être mis à jour
            skyMat.needsUpdate = true;

            // Continuer l'animation jusqu'à ce que le fondu soit terminé
            if (progress < 1) {
              requestAnimationFrame(animateColorTransition);
            }
          };

          // Appeler la fonction de changement de couleur toutes les 2 minutes
          setInterval(() => {
            changeSkyColor(); // Démarrer le changement de couleur
            requestAnimationFrame(animateColorTransition); // Commencer l'animation de fondu
          }, 1 * 5 * 1000); // 2 minutes

          // Accéder à la caméra et modifier les paramètres near et far
          this.third.camera.near = 0.1; // Distance minimale de rendu (par défaut c'est souvent 0.1)
          this.third.camera.far = 100000; // Augmente la distance maximale de rendu à 2000
          this.third.camera.updateProjectionMatrix(); // Applique les changements

          // Charger les textures pour la face supérieure et les côtés
          const topTexture = textureLoader.load("/5/test3D/examples/grass.jpg");
          const sideTexture = textureLoader.load(
            "/5/test3D/examples/cliff.jpg"
          );

          const waterTexture = textureLoader.load("/5/test3D/examples/eau.png");

          sideTexture.wrapS = THREE.RepeatWrapping;
          sideTexture.wrapT = THREE.RepeatWrapping;
          sideTexture.repeat.set(5, 1);

          topTexture.wrapS = THREE.RepeatWrapping;
          topTexture.wrapT = THREE.RepeatWrapping;
          topTexture.repeat.set(5, 5);

          // Créer des matériaux distincts pour chaque face
          const materials = [
            new THREE.MeshBasicMaterial({ map: sideTexture }), // Face 1
            new THREE.MeshBasicMaterial({ map: sideTexture }), // Face 2
            new THREE.MeshBasicMaterial({ map: topTexture }), // Face 3
            new THREE.MeshBasicMaterial({ map: sideTexture }), // Face 4
            new THREE.MeshBasicMaterial({ map: sideTexture }), // Face supérieure
            new THREE.MeshBasicMaterial({ map: sideTexture }), // Face inférieure (si nécessaire)
          ];

          const waterMaterial = new THREE.MeshBasicMaterial({
            map: waterTexture,
            transparent: true, // Optionnel si tu veux rendre l'eau partiellement transparente
            opacity: 0.7, // Ajuste la transparence
            side: THREE.DoubleSide, // Pour rendre visible l'eau des deux côtés
          });

          // Créer une géométrie, ici un cube
          const cubeGeometry = new THREE.BoxGeometry(4000, 500, 4000);
          const cubeWater = new THREE.BoxGeometry(8000, -5, 8000);

          // Appliquer le tableau de matériaux au cube
          const cube = new THREE.Mesh(cubeGeometry, materials);
          const water = new THREE.Mesh(cubeWater, waterMaterial);

          // Ajouter le cube à la scène
          cube.position.set(0, 1, 0);
          water.position.set(0, -1, 0);

          this.third.scene.add(cube);
          this.third.scene.add(water);

          const heightMapTexture = new THREE.TextureLoader().load(
            "/5/test3D/examples/heightmap-island.png",
            (texture) => {
              texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

              // Créer un grand plan carré pour le terrain
              const terrainSize = 12500; // Taille du terrain
              const segments = 256;

              // Créer la géométrie du plan
              const planeGeometry = new THREE.PlaneGeometry(
                terrainSize,
                terrainSize,
                segments,
                segments
              );

              // Créer le matériau avec la displacement map
              const planeMaterial = new THREE.MeshPhongMaterial({
                color: 0x8b4513,
                side: THREE.DoubleSide,
                displacementMap: heightMapTexture,
                displacementScale: 2500,
              });

              // Créer le mesh du terrain
              const terrain = new THREE.Mesh(planeGeometry, planeMaterial);
              terrain.rotation.x = -Math.PI / 2;
              terrain.position.y = -10;

              // Aplatir la zone où se trouve l'eau

              this.third.scene.add(terrain);

              // Ajouter le bloc d'eau
              const waterTexture = new THREE.TextureLoader().load(
                "/5/test3D/examples/eau.png"
              );
              const waterMaterial = new THREE.MeshBasicMaterial({
                map: waterTexture,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide,
              });

              const waterGeometry = new THREE.CircleGeometry(waterRadius, 64);
              const water = new THREE.Mesh(waterGeometry, waterMaterial);
              water.rotation.x = -Math.PI / 2;
              water.position.y = -1;

              this.third.scene.add(water);

              // Créer et positionner les rectangles autour du bloc d'eau
              const rectangleWidth = 6000;
              const rectangleHeight = 3000;

              const rectGeometry = new THREE.PlaneGeometry(
                rectangleWidth,
                rectangleHeight,
                1,
                1
              );
              const rectMaterial = new THREE.MeshPhongMaterial({
                color: 0x8b4513, // Couleur de base
                side: THREE.DoubleSide,
                displacementMap: heightMapTexture,
                displacementScale: -100000, // Ajuster pour le relief
              });

              // Positions des rectangles
              const positions = [
                { x: 0, z: -waterRadius - rectangleHeight / 2 }, // Dessus
                { x: 0, z: waterRadius + rectangleHeight / 2 }, // Dessous
                { x: -waterRadius - rectangleWidth / 2, z: 0 }, // Gauche
                { x: waterRadius + rectangleWidth / 2, z: 0 }, // Droite
              ];

              positions.forEach((pos) => {
                const rectangle = new THREE.Mesh(rectGeometry, rectMaterial);
                rectangle.rotation.x = -Math.PI / 2; // Orienter le rectangle horizontalement
                rectangle.position.set(pos.x, -10, pos.z); // Positionner les rectangles
                this.third.scene.add(rectangle);
              });
            }
          );

          var heightMap = new THREE.TextureLoader().load(
            "/5/test3D/examples/heightmap-island.png"
          );
          const planeGeometry = new THREE.PlaneGeometry(1000, 1000, 1000, 1000);
          const planeMaterial = new THREE.MeshPhongMaterial({
            color: 0xff0000,
            side: THREE.DoubleSide,
            displacementMap: heightMap,
            displacementScale: -50,
          });
          const mesh = new THREE.Mesh(planeGeometry, planeMaterial);
          mesh.rotation.x = Math.PI / 2;
          this.third.scene.add(mesh);

          textureLoader.load("/5/test3D/examples/maison.jpg", (texture) => {
            const planeGeometry = new THREE.PlaneGeometry(10, 10);
            const planeMaterial = new THREE.MeshBasicMaterial({
              map: texture,
              side: THREE.DoubleSide,
              transparent: true,
              alphaTest: 0.5,
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);

            plane.position.set(0, 60, -5);
            plane.rotation.y = 0;

            this.third.scene.add(plane);
          });

          textureLoader.load("/5/test3D/examples/maison.jpg", (texture) => {
            const planeGeometry = new THREE.PlaneGeometry(10, 10);
            const planeMaterial = new THREE.MeshBasicMaterial({
              map: texture,
              side: THREE.DoubleSide,
              transparent: true,
              alphaTest: 0.5,
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);

            plane.position.set(0, 60, -5);
            plane.rotation.y = 0;

            this.third.scene.add(plane);
          });
          const loader = new THREE.TextureLoader();
          const grassTexture = loader.load("/5/test3D/examples/herbe.png");

          const grassGeometry = new THREE.PlaneGeometry(1, 2);

          const grassMaterial = new THREE.MeshBasicMaterial({
            map: grassTexture,
            transparent: true,
            side: THREE.DoubleSide,
            alphaTest: 0.5,
            depthWrite: true,
          });

          const grassCount = 1000;
          const grassMesh = new THREE.InstancedMesh(
            grassGeometry,
            grassMaterial,
            grassCount
          );

          const dummy = new THREE.Object3D();
          for (let i = 0; i < grassCount; i++) {
            dummy.position.set(
              (Math.random() - 0.5) * 50,
              52,
              (Math.random() - 0.5) * 50
            );

            dummy.rotation.y = Math.random() * Math.PI;
            dummy.updateMatrix();
            grassMesh.setMatrixAt(i, dummy.matrix);
          }

          this.third.scene.add(grassMesh);

          textureLoader.load("/5/test3D/examples/bush.png", (texture) => {
            const planeGeometry = new THREE.PlaneGeometry(2.5, 2.5);
            const planeMaterial = new THREE.MeshBasicMaterial({
              map: texture,
              side: THREE.DoubleSide,
              transparent: true,
              alphaTest: 0.5,
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);

            plane.position.set(0, 52, 3);
            plane.rotation.y = 0;

            this.third.scene.add(plane);
          });

          const framePaths = [];
          for (let i = 1; i <= 10; i++) {
            framePaths.push(`/5/test3D/examples/png/Walk (${i}).png`);
          }

          const walkTextures = [];
          let framesLoaded = 0;

          framePaths.forEach((path, index) => {
            textureLoader.load(path, (texture) => {
              walkTextures[index] = texture;
              framesLoaded++;

              if (framesLoaded === framePaths.length) {
                this.createWalkAnimation(walkTextures);
              }
            });
          });

          this.input.mouse.disableContextMenu();

          this.keys = {
            left: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),
            right: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
            forward: this.input.keyboard.addKey(
              Phaser.Input.Keyboard.KeyCodes.Z
            ),
            backward: this.input.keyboard.addKey(
              Phaser.Input.Keyboard.KeyCodes.S
            ),
          };

          // Étape 1 : Créer un terrain plat
          const terrainGeometry = new THREE.PlaneGeometry(4000, 4000, 100, 100); // Terrain plat de 4000x4000
          const terrainMaterial = new THREE.MeshLambertMaterial({
            map: textureLoader.load("/5/test3D/examples/grass.jpg"), // Appliquer une texture d'herbe
            side: THREE.DoubleSide, // Permet de voir des deux côtés du terrain
          });

          const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);

          // Positionner correctement le terrain
          terrain.rotation.x = -Math.PI / 2; // Aligne le terrain horizontalement
          terrain.position.y = 0; // Place le terrain à la hauteur 0

          this.third.scene.add(terrain); // Ajoute le terrain à la scène

          // Parcourir les sommets de la géométrie pour les déformer
          const vertices = terrainGeometry.attributes.position.array;

          for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i]; // Coordonnée X du sommet
            const y = vertices[i + 1]; // Coordonnée Y du sommet (qui ne change pas)
            const z = vertices[i + 2]; // Coordonnée Z du sommet (que nous allons modifier)

            // Appliquer un relief simple basé sur la coordonnée X et Y
            const height = Math.sin(x / 100) * 20 + Math.cos(y / 100) * 20;

            vertices[i + 2] = height; // Modifier la coordonnée Z pour ajouter du relief
          }

          // Dire à Three.js de mettre à jour la géométrie après modification
          terrainGeometry.attributes.position.needsUpdate = true;
          terrainGeometry.computeVertexNormals(); // Recalculer les normales pour l'éclairage
        }

        createWalkAnimation(walkTextures) {
          const geometry = new THREE.PlaneGeometry(2.5, 2.5);
          const material = new THREE.MeshBasicMaterial({
            map: walkTextures[0],
            side: THREE.DoubleSide,
            transparent: true,
            alphaTest: 0.5,
          });
          const walkPlane = new THREE.Mesh(geometry, material);
          walkPlane.position.set(0, 52, 0);
          this.third.scene.add(walkPlane);

          let currentFrame = 0;
          const totalFrames = walkTextures.length;
          let isWalking = false;
          let direction = 1;

          const animateWalk = () => {
            if (isWalking) {
              material.map = walkTextures[currentFrame];
              material.needsUpdate = true;
              currentFrame = (currentFrame + 1) % totalFrames;
              setTimeout(animateWalk, 100);
            }
          };

          animateWalk();

          this.events.on("update", () => {
            if (
              this.keys.left.isDown ||
              this.keys.right.isDown ||
              this.keys.forward.isDown ||
              this.keys.backward.isDown
            ) {
              if (!isWalking) {
                isWalking = true;
                animateWalk();
              }

              if (this.keys.left.isDown) {
                walkPlane.position.x -= 0.05;
                if (direction !== -1) {
                  walkPlane.scale.x = -1;
                  direction = -1;
                }
              } else if (this.keys.right.isDown) {
                walkPlane.position.x += 0.05;
                if (direction !== 1) {
                  walkPlane.scale.x = 1;
                  direction = 1;
                }
              }
              // Déplacement avant/arrière
              if (this.keys.forward.isDown) {
                walkPlane.position.z -= 0.05; // Se déplacer vers l'avant (réduit Z)
              } else if (this.keys.backward.isDown) {
                walkPlane.position.z += 0.05; // Se déplacer vers l'arrière (augmente Z)
              }
            } else {
              isWalking = false;
            }
          });
        }
      }

      const config = {
        type: Phaser.WEBGL,
        transparent: true,
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
          width: window.innerWidth * Math.max(1, window.devicePixelRatio / 2),
          height: window.innerHeight * Math.max(1, window.devicePixelRatio / 2),
        },
        scene: [MainScene],
        ...Canvas(),
      };

      window.addEventListener("load", () => {
        enable3d(() => new Phaser.Game(config)).withPhysics(
          "/lib/ammo/kripken"
        );
      });
    </script>
  </body>
</html>
